# -*- coding: utf-8 -*-
"""Prova_IA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g3uLdPh_y1rG7oGDso6POmmuMqIq19Ew

# PROVA DE INTELIGÊNCIA ARTIFICIAL
# Questão 1
"""

import pandas as pd


## Carregue o dataset definido para você
diabetes = pd.read_csv(r"/content/diabetes_binary_health_indicators_BRFSS2015.csv")
print(diabetes.shape)

# Verifique se existem celulas vazias ou Nan. Se existir, excluir e criar um novo dataframe.
print(diabetes.isna().sum())
print(diabetes.isnull().sum())
print(diabetes.dropna())
print(diabetes.shape)

# Verifique quais colunas são as mais relevantes e crie um novo dataframe.
#excluindo as colunas que eu não quero
diabetes = diabetes.drop(["CholCheck", "Education", "Income", "MentHlth", "GenHlth", "NoDocbcCost", "Smoker","AnyHealthcare", "DiffWalk","Fruits", "Veggies", "Stroke", "HeartDiseaseorAttack","Smoker" ], axis=1)

#traduzindo o nome das colunas
diabetes_ajustado = diabetes.rename(columns={"Diabetes_binary":"Diabetes",
                                    "HighBP": "Pressão_Alta",
                                    "HighChol": "Colesterol_alto",
                                    "BMI": "IMC",
                                    "PhysActivity": "Atividade_fisica",
                                    "HvyAlcoholConsump": "Consumo_Alcool",
                                    "PhysHlth": "Saude_fisica",
                                    "Sex": "Genero",
                                    "Age": "Idade"})

print(diabetes_ajustado.info())

#Print o dataframe final e mostre a distribuição de classes que você deve classificar
print(diabetes_ajustado["Diabetes"].value_counts())
print(diabetes_ajustado["Pressão_Alta"].value_counts())
print(diabetes_ajustado["Colesterol_alto"].value_counts())
print(diabetes_ajustado["Consumo_Alcool"].value_counts())
print(diabetes_ajustado["Atividade_fisica"].value_counts())
print(diabetes_ajustado["Genero"].value_counts())
print(diabetes_ajustado["Idade"].value_counts())
#observe se a coluna de classes precisa ser renomeada para atributos numéricos, realize a conversão, se necessário
# O dataset já estava categorizado. 0 para quem não tem Diabetes, 1 para pré-diabetes e 2 para diabetes normal
# pressão alta: 0 para não e 1 para sim
# Colesterol_alto: 0 para não e 1 para sim
# Consumo_Alcool: 0 para não e 1 para sim
# Atividade_fisica: : 0 para não e 1 para sim
# Genero: feminino 0, masculino 1
# Idade:
# 1 Idade 18 a 24
# 2 Idade 25 a 29
# 3 Idade 30 a 34
# 4 Idade 35 a 39
# 5 Idade 40 a 44
# 6 Idade 45 a 49
# 7 Idade 50 a 54
# 8 Idade 55 a 59
# 9 Idade 60 a 64
# 10 Idade 65 a 69
# 11 Idade 70 a 74
# 12 Idade 75 a 79
# 13 80 anos ou mais
#### Saúde física: quanto tempo ficou machucado

diabetes_ajustado.to_csv(r"/content/diabetes_ajustado.csv")

"""# Questão 2"""

from sqlalchemy.sql.expression import select
#realizar uma classificação utilizando KNN.

#Importe as bibliotecas necessárias.
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier


#Carregue o dataset. Se houver o dataset atualizado, carregue o atualizado.
diabetes_ajustado = pd.read_csv(r"/content/diabetes_ajustado.csv")
print(diabetes_ajustado.info)

#Sem normalizar o conjunto de dados divida o dataset em treino e teste.

X = diabetes_ajustado.drop(["Diabetes"], axis=1).values
y = diabetes_ajustado [["Diabetes"]].values
X_train, X_test, y_train, y_test = train_test_split(X , y, stratify= y, random_state=42)

#Implemente o Knn exbindo sua acurácia nos dados de teste e mantenha sua parametrização default.

knn = KNeighborsClassifier()
knn.fit(X_train,y_train) #problema no fit
print("score", knn.score(X_test, y_test))

"""# Questão 3"""

#Importe as bibliotecas necessárias.
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neighbors import KNeighborsRegressor
#from sqlalchemy import String
#from IPython.utils.text import string
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import normalize, StandardScaler

#Carregue o dataset. Se houver o dataset atualizado, carregue o atualizado.
#diabetes = pd.read_csv(r"/content/diabetes_ajustado.csv")

#Normalize o conjunto de dados com normalização logarítmica e verifique a acurácia do knn.
X = diabetes_ajustado.drop('Diabetes', axis=1)
y = diabetes_ajustado['Diabetes']
X_norm_log = normalize(X, norm='l2')
X_train_log, X_test_log, y_train_log, y_test_log = train_test_split(X_norm_log, y, test_size=0.3, random_state=42, stratify=y)

knn = KNeighborsClassifier()
knn.fit(X_train_log, y_train_log)

y_pred_log = knn.predict(X_test_log)
acuracia_log = accuracy_score(y_test_log, y_pred_log)

#Normalize o conjunto de dados com normalização de media zero e variância unitária e e verifique a acurácia do knn.
scaler = StandardScaler()

X_norm_scaler = scaler.fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X_norm_scaler, y, test_size=0.3, random_state=42, stratify=y)
knn.fit(X_train, y_train)
y_pred_scaler = knn.predict(X_test)
acc_scaler = accuracy_score(y_test, y_pred_scaler)

#Print as duas acuracias lado a lado para comparar.
print("Acurácia")
print('Normalização logarítmica : {:.2f}%'.format(acuracia_log * 100),"     " 'Nnormalização média zero e variância unitária: {:.2f}%'.format(acc_scaler * 100))

"""# Questão 4"""

from sklearn.metrics import accuracy_score
from sklearn.preprocessing import normalize, StandardScaler
 #melhor parametrização do knn.
X = diabetes_ajustado.drop("Diabetes", axis=1)
y = diabetes_ajustado["Diabetes"]

knn=KNeighborsClassifier()
scaler = StandardScaler()

X_norm_scaler = scaler.fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X_norm_scaler, y, test_size=0.3, random_state=42, stratify=y)

knn.fit(X_train, y_train)
y_predscaler = knn.predict(X_test)
acc_scaler = accuracy_score(y_test, y_predscaler)

print('Acurácia com normalização de média zero e variância unitária: {:.2f}%'.format(acc_scaler * 100))

#Plote o gráfico com o a indicação do melhor k.
neighbors = np.arange(1, 20)
train_accuracies = {}
test_accuracies = {}

for neighbor in neighbors:
    knn = KNeighborsClassifier(n_neighbors=neighbor)
    knn.fit(X_train, y_train)

    train_accuracies[neighbor] = knn.score(X_train, y_train)
    test_accuracies[neighbor] = knn.score(X_test, y_test)

print("Acurácia treino: ",train_accuracies, '\n', 'Acuráciateste: ',test_accuracies)

plt.title("Número de vizinhos:")

plt.plot(neighbors, train_accuracies.values(), label="Acurácia do treino")
plt.plot(neighbors, test_accuracies.values(), label="Acurácia do teste")

plt.legend()
plt.xlabel("Números de vizinhos")
plt.ylabel("Acurácia")

plt.show()